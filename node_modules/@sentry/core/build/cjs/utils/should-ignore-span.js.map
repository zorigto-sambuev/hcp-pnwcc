{"version":3,"file":"should-ignore-span.js","sources":["../../../src/utils/should-ignore-span.ts"],"sourcesContent":["import type { ClientOptions } from '../types-hoist/options';\nimport type { SpanJSON } from '../types-hoist/span';\nimport { isMatchingPattern } from './string';\n\n/**\n * Check if a span should be ignored based on the ignoreSpans configuration.\n */\nexport function shouldIgnoreSpan(\n  span: Pick<SpanJSON, 'description' | 'op'>,\n  ignoreSpans: Required<ClientOptions>['ignoreSpans'],\n): boolean {\n  if (!ignoreSpans?.length || !span.description) {\n    return false;\n  }\n\n  for (const pattern of ignoreSpans) {\n    if (isStringOrRegExp(pattern)) {\n      if (isMatchingPattern(span.description, pattern)) {\n        return true;\n      }\n      continue;\n    }\n\n    if (!pattern.name && !pattern.op) {\n      continue;\n    }\n\n    const nameMatches = pattern.name ? isMatchingPattern(span.description, pattern.name) : true;\n    const opMatches = pattern.op ? span.op && isMatchingPattern(span.op, pattern.op) : true;\n\n    // This check here is only correct because we can guarantee that we ran `isMatchingPattern`\n    // for at least one of `nameMatches` and `opMatches`. So in contrary to how this looks,\n    // not both op and name actually have to match. This is the most efficient way to check\n    // for all combinations of name and op patterns.\n    if (nameMatches && opMatches) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Takes a list of spans, and a span that was dropped, and re-parents the child spans of the dropped span to the parent of the dropped span, if possible.\n * This mutates the spans array in place!\n */\nexport function reparentChildSpans(spans: SpanJSON[], dropSpan: SpanJSON): void {\n  const droppedSpanParentId = dropSpan.parent_span_id;\n  const droppedSpanId = dropSpan.span_id;\n\n  // This should generally not happen, as we do not apply this on root spans\n  // but to be safe, we just bail in this case\n  if (!droppedSpanParentId) {\n    return;\n  }\n\n  for (const span of spans) {\n    if (span.parent_span_id === droppedSpanId) {\n      span.parent_span_id = droppedSpanParentId;\n    }\n  }\n}\n\nfunction isStringOrRegExp(value: unknown): value is string | RegExp {\n  return typeof value === 'string' || value instanceof RegExp;\n}\n"],"names":["isMatchingPattern"],"mappings":";;;;AAIA;AACA;AACA;AACO,SAAS,gBAAgB;AAChC,EAAE,IAAI;AACN,EAAE,WAAW;AACb,EAAW;AACX,EAAE,IAAI,CAAC,WAAW,EAAE,MAAA,IAAU,CAAC,IAAI,CAAC,WAAW,EAAE;AACjD,IAAI,OAAO,KAAK;AAChB;;AAEA,EAAE,KAAK,MAAM,OAAA,IAAW,WAAW,EAAE;AACrC,IAAI,IAAI,gBAAgB,CAAC,OAAO,CAAC,EAAE;AACnC,MAAM,IAAIA,wBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,EAAE;AACxD,QAAQ,OAAO,IAAI;AACnB;AACA,MAAM;AACN;;AAEA,IAAI,IAAI,CAAC,OAAO,CAAC,IAAA,IAAQ,CAAC,OAAO,CAAC,EAAE,EAAE;AACtC,MAAM;AACN;;AAEA,IAAI,MAAM,WAAA,GAAc,OAAO,CAAC,IAAA,GAAOA,wBAAiB,CAAC,IAAI,CAAC,WAAW,EAAE,OAAO,CAAC,IAAI,CAAA,GAAI,IAAI;AAC/F,IAAI,MAAM,YAAY,OAAO,CAAC,EAAA,GAAK,IAAI,CAAC,EAAA,IAAMA,wBAAiB,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,CAAA,GAAI,IAAI;;AAE3F;AACA;AACA;AACA;AACA,IAAI,IAAI,WAAA,IAAe,SAAS,EAAE;AAClC,MAAM,OAAO,IAAI;AACjB;AACA;;AAEA,EAAE,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACO,SAAS,kBAAkB,CAAC,KAAK,EAAc,QAAQ,EAAkB;AAChF,EAAE,MAAM,mBAAA,GAAsB,QAAQ,CAAC,cAAc;AACrD,EAAE,MAAM,aAAA,GAAgB,QAAQ,CAAC,OAAO;;AAExC;AACA;AACA,EAAE,IAAI,CAAC,mBAAmB,EAAE;AAC5B,IAAI;AACJ;;AAEA,EAAE,KAAK,MAAM,IAAA,IAAQ,KAAK,EAAE;AAC5B,IAAI,IAAI,IAAI,CAAC,cAAA,KAAmB,aAAa,EAAE;AAC/C,MAAM,IAAI,CAAC,cAAA,GAAiB,mBAAmB;AAC/C;AACA;AACA;;AAEA,SAAS,gBAAgB,CAAC,KAAK,EAAqC;AACpE,EAAE,OAAO,OAAO,KAAA,KAAU,YAAY,KAAA,YAAiB,MAAM;AAC7D;;;;;"}