{"version":3,"file":"instrumentation.js","sources":["../../../../../src/integrations/tracing/vercelai/instrumentation.ts"],"sourcesContent":["import type { InstrumentationConfig, InstrumentationModuleDefinition } from '@opentelemetry/instrumentation';\nimport { InstrumentationBase, InstrumentationNodeModuleDefinition } from '@opentelemetry/instrumentation';\nimport type { Span } from '@sentry/core';\nimport {\n  _INTERNAL_cleanupToolCallSpan,\n  _INTERNAL_getSpanForToolCallId,\n  addNonEnumerableProperty,\n  captureException,\n  getActiveSpan,\n  getCurrentScope,\n  handleCallbackErrors,\n  SDK_VERSION,\n  withScope,\n} from '@sentry/core';\nimport { INTEGRATION_NAME } from './constants';\nimport type { TelemetrySettings, VercelAiIntegration } from './types';\n\n// List of patched methods\n// From: https://sdk.vercel.ai/docs/ai-sdk-core/telemetry#collected-data\nconst INSTRUMENTED_METHODS = [\n  'generateText',\n  'streamText',\n  'generateObject',\n  'streamObject',\n  'embed',\n  'embedMany',\n] as const;\n\ninterface MethodFirstArg extends Record<string, unknown> {\n  experimental_telemetry?: TelemetrySettings;\n}\n\ntype MethodArgs = [MethodFirstArg, ...unknown[]];\n\ntype PatchedModuleExports = Record<(typeof INSTRUMENTED_METHODS)[number], (...args: MethodArgs) => unknown> &\n  Record<string, unknown>;\n\ninterface RecordingOptions {\n  recordInputs?: boolean;\n  recordOutputs?: boolean;\n}\n\ninterface ToolError {\n  type: 'tool-error' | 'tool-result' | 'tool-call';\n  toolCallId: string;\n  toolName: string;\n  input?: {\n    [key: string]: unknown;\n  };\n  error: Error;\n  dynamic?: boolean;\n}\n\nfunction isToolError(obj: unknown): obj is ToolError {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const candidate = obj as Record<string, unknown>;\n  return (\n    'type' in candidate &&\n    'error' in candidate &&\n    'toolName' in candidate &&\n    'toolCallId' in candidate &&\n    candidate.type === 'tool-error' &&\n    candidate.error instanceof Error\n  );\n}\n\n/**\n * Check for tool errors in the result and capture them\n * Tool errors are not rejected in Vercel V5, it is added as metadata to the result content\n */\nfunction checkResultForToolErrors(result: unknown | Promise<unknown>): void {\n  if (typeof result !== 'object' || result === null || !('content' in result)) {\n    return;\n  }\n\n  const resultObj = result as { content: Array<object> };\n  if (!Array.isArray(resultObj.content)) {\n    return;\n  }\n\n  for (const item of resultObj.content) {\n    if (isToolError(item)) {\n      // Try to get the span associated with this tool call ID\n      const associatedSpan = _INTERNAL_getSpanForToolCallId(item.toolCallId) as Span;\n\n      if (associatedSpan) {\n        // We have the span, so link the error using span and trace IDs from the span\n        const spanContext = associatedSpan.spanContext();\n\n        withScope(scope => {\n          // Set the span and trace context for proper linking\n          scope.setContext('trace', {\n            trace_id: spanContext.traceId,\n            span_id: spanContext.spanId,\n          });\n\n          scope.setTag('vercel.ai.tool.name', item.toolName);\n          scope.setTag('vercel.ai.tool.callId', item.toolCallId);\n\n          scope.setLevel('error');\n\n          captureException(item.error, {\n            mechanism: {\n              type: 'auto.vercelai.otel',\n              handled: false,\n            },\n          });\n        });\n\n        // Clean up the span mapping since we've processed this tool error\n        // We won't get multiple { type: 'tool-error' } parts for the same toolCallId.\n        _INTERNAL_cleanupToolCallSpan(item.toolCallId);\n      } else {\n        // Fallback: capture without span linking\n        withScope(scope => {\n          scope.setTag('vercel.ai.tool.name', item.toolName);\n          scope.setTag('vercel.ai.tool.callId', item.toolCallId);\n          scope.setLevel('error');\n\n          captureException(item.error, {\n            mechanism: {\n              type: 'auto.vercelai.otel',\n              handled: false,\n            },\n          });\n        });\n      }\n    }\n  }\n}\n\n/**\n * Determines whether to record inputs and outputs for Vercel AI telemetry based on the configuration hierarchy.\n *\n * The order of precedence is:\n * 1. The vercel ai integration options\n * 2. The experimental_telemetry options in the vercel ai method calls\n * 3. When telemetry is explicitly enabled (isEnabled: true), default to recording\n * 4. Otherwise, use the sendDefaultPii option from client options\n */\nexport function determineRecordingSettings(\n  integrationRecordingOptions: RecordingOptions | undefined,\n  methodTelemetryOptions: RecordingOptions,\n  telemetryExplicitlyEnabled: boolean | undefined,\n  defaultRecordingEnabled: boolean,\n): { recordInputs: boolean; recordOutputs: boolean } {\n  const recordInputs =\n    integrationRecordingOptions?.recordInputs !== undefined\n      ? integrationRecordingOptions.recordInputs\n      : methodTelemetryOptions.recordInputs !== undefined\n        ? methodTelemetryOptions.recordInputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  const recordOutputs =\n    integrationRecordingOptions?.recordOutputs !== undefined\n      ? integrationRecordingOptions.recordOutputs\n      : methodTelemetryOptions.recordOutputs !== undefined\n        ? methodTelemetryOptions.recordOutputs\n        : telemetryExplicitlyEnabled === true\n          ? true // When telemetry is explicitly enabled, default to recording inputs\n          : defaultRecordingEnabled;\n\n  return { recordInputs, recordOutputs };\n}\n\n/**\n * This detects is added by the Sentry Vercel AI Integration to detect if the integration should\n * be enabled.\n *\n * It also patches the `ai` module to enable Vercel AI telemetry automatically for all methods.\n */\nexport class SentryVercelAiInstrumentation extends InstrumentationBase {\n  private _isPatched = false;\n  private _callbacks: (() => void)[] = [];\n\n  public constructor(config: InstrumentationConfig = {}) {\n    super('@sentry/instrumentation-vercel-ai', SDK_VERSION, config);\n  }\n\n  /**\n   * Initializes the instrumentation by defining the modules to be patched.\n   */\n  public init(): InstrumentationModuleDefinition {\n    const module = new InstrumentationNodeModuleDefinition('ai', ['>=3.0.0 <6'], this._patch.bind(this));\n    return module;\n  }\n\n  /**\n   * Call the provided callback when the module is patched.\n   * If it has already been patched, the callback will be called immediately.\n   */\n  public callWhenPatched(callback: () => void): void {\n    if (this._isPatched) {\n      callback();\n    } else {\n      this._callbacks.push(callback);\n    }\n  }\n\n  /**\n   * Patches module exports to enable Vercel AI telemetry.\n   */\n  private _patch(moduleExports: PatchedModuleExports): unknown {\n    this._isPatched = true;\n\n    this._callbacks.forEach(callback => callback());\n    this._callbacks = [];\n\n    function generatePatch(originalMethod: (...args: MethodArgs) => unknown) {\n      return (...args: MethodArgs) => {\n        const existingExperimentalTelemetry = args[0].experimental_telemetry || {};\n        const isEnabled = existingExperimentalTelemetry.isEnabled;\n\n        const client = getCurrentScope().getClient();\n        const integration = client?.getIntegrationByName<VercelAiIntegration>(INTEGRATION_NAME);\n        const integrationOptions = integration?.options;\n        const shouldRecordInputsAndOutputs = integration ? Boolean(client?.getOptions().sendDefaultPii) : false;\n\n        const { recordInputs, recordOutputs } = determineRecordingSettings(\n          integrationOptions,\n          existingExperimentalTelemetry,\n          isEnabled,\n          shouldRecordInputsAndOutputs,\n        );\n\n        args[0].experimental_telemetry = {\n          ...existingExperimentalTelemetry,\n          isEnabled: isEnabled !== undefined ? isEnabled : true,\n          recordInputs,\n          recordOutputs,\n        };\n\n        return handleCallbackErrors(\n          async () => {\n            // @ts-expect-error we know that the method exists\n            const result = await originalMethod.apply(this, args);\n\n            // Tool errors are not rejected in Vercel V5, it is added as metadata to the result content\n            checkResultForToolErrors(result);\n\n            return result;\n          },\n          error => {\n            // This error bubbles up to unhandledrejection handler (if not handled before),\n            // where we do not know the active span anymore\n            // So to circumvent this, we set the active span on the error object\n            // which is picked up by the unhandledrejection handler\n            if (error && typeof error === 'object') {\n              addNonEnumerableProperty(error, '_sentry_active_span', getActiveSpan());\n            }\n          },\n        );\n      };\n    }\n\n    // Is this an ESM module?\n    // https://tc39.es/ecma262/#sec-module-namespace-objects\n    if (Object.prototype.toString.call(moduleExports) === '[object Module]') {\n      // In ESM we take the usual route and just replace the exports we want to instrument\n      for (const method of INSTRUMENTED_METHODS) {\n        moduleExports[method] = generatePatch(moduleExports[method]);\n      }\n\n      return moduleExports;\n    } else {\n      // In CJS we can't replace the exports in the original module because they\n      // don't have setters, so we create a new object with the same properties\n      const patchedModuleExports = INSTRUMENTED_METHODS.reduce((acc, curr) => {\n        acc[curr] = generatePatch(moduleExports[curr]);\n        return acc;\n      }, {} as PatchedModuleExports);\n\n      return { ...moduleExports, ...patchedModuleExports };\n    }\n  }\n}\n"],"names":["_INTERNAL_getSpanForToolCallId","withScope","captureException","_INTERNAL_cleanupToolCallSpan","InstrumentationBase","SDK_VERSION","InstrumentationNodeModuleDefinition","getCurrentScope","INTEGRATION_NAME","handleCallbackErrors","addNonEnumerableProperty","getActiveSpan"],"mappings":"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"}