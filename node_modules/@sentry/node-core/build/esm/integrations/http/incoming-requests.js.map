{"version":3,"file":"incoming-requests.js","sources":["../../../../src/integrations/http/incoming-requests.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Span } from '@opentelemetry/api';\nimport { context, createContextKey, propagation, SpanKind, trace } from '@opentelemetry/api';\nimport type { RPCMetadata } from '@opentelemetry/core';\nimport { getRPCMetadata, isTracingSuppressed, RPCType, setRPCMetadata } from '@opentelemetry/core';\nimport {\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_HTTP_ROUTE,\n  SEMATTRS_HTTP_STATUS_CODE,\n  SEMATTRS_NET_HOST_IP,\n  SEMATTRS_NET_HOST_PORT,\n  SEMATTRS_NET_PEER_IP,\n} from '@opentelemetry/semantic-conventions';\nimport type { AggregationCounts, Client, Scope, SpanAttributes, SpanStatus } from '@sentry/core';\nimport {\n  debug,\n  generateSpanId,\n  getClient,\n  getCurrentScope,\n  getIsolationScope,\n  getSpanStatusFromHttpCode,\n  httpRequestToRequestData,\n  parseStringToURLObject,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SPAN_STATUS_ERROR,\n  stripUrlQueryAndFragment,\n  withIsolationScope,\n} from '@sentry/core';\nimport type EventEmitter from 'events';\nimport { errorMonitor } from 'events';\nimport type { ClientRequest, IncomingHttpHeaders, IncomingMessage, Server, ServerResponse } from 'http';\nimport type { Socket } from 'net';\nimport { DEBUG_BUILD } from '../../debug-build';\nimport type { NodeClient } from '../../sdk/client';\nimport { INSTRUMENTATION_NAME, MAX_BODY_BYTE_LENGTH } from './constants';\n\n// Tree-shakable guard to remove all code related to tracing\ndeclare const __SENTRY_TRACING__: boolean;\n\ntype ServerEmit = typeof Server.prototype.emit;\n\nconst HTTP_SERVER_INSTRUMENTED_KEY = createContextKey('sentry_http_server_instrumented');\n\nconst clientToRequestSessionAggregatesMap = new Map<\n  Client,\n  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }\n>();\n\n// We keep track of emit functions we wrapped, to avoid double wrapping\n// We do this instead of putting a non-enumerable property on the function, because\n// sometimes the property seems to be migrated to forks of the emit function, which we do not want to happen\n// This was the case in the nestjs-distributed-tracing E2E test\nconst wrappedEmitFns = new WeakSet<ServerEmit>();\n\n/**\n * Instrument a server to capture incoming requests.\n *\n */\nexport function instrumentServer(\n  server: Server,\n  {\n    ignoreIncomingRequestBody,\n    ignoreSpansForIncomingRequests,\n    maxIncomingRequestBodySize = 'medium',\n    trackIncomingRequestsAsSessions = true,\n    spans,\n    ignoreStaticAssets = true,\n    sessionFlushingDelayMS,\n    // eslint-disable-next-line deprecation/deprecation\n    instrumentation,\n    incomingRequestSpanHook,\n  }: {\n    ignoreIncomingRequestBody?: (url: string, request: IncomingMessage) => boolean;\n    ignoreSpansForIncomingRequests?: (urlPath: string, request: IncomingMessage) => boolean;\n    maxIncomingRequestBodySize?: 'small' | 'medium' | 'always' | 'none';\n    trackIncomingRequestsAsSessions?: boolean;\n    sessionFlushingDelayMS: number;\n    spans: boolean;\n    ignoreStaticAssets?: boolean;\n    incomingRequestSpanHook?: (span: Span, request: IncomingMessage, response: ServerResponse) => void;\n    /** @deprecated Use `incomingRequestSpanHook` instead. */\n    instrumentation?: {\n      requestHook?: (span: Span, req: IncomingMessage | ClientRequest) => void;\n      responseHook?: (span: Span, response: ServerResponse | IncomingMessage) => void;\n      applyCustomAttributesOnSpan?: (\n        span: Span,\n        request: IncomingMessage | ClientRequest,\n        response: ServerResponse | IncomingMessage,\n      ) => void;\n    };\n  },\n): void {\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const originalEmit: ServerEmit = server.emit;\n\n  if (wrappedEmitFns.has(originalEmit)) {\n    DEBUG_BUILD &&\n      debug.log(INSTRUMENTATION_NAME, 'Incoming requests already instrumented, not instrumenting again...');\n    return;\n  }\n\n  const { requestHook, responseHook, applyCustomAttributesOnSpan } = instrumentation ?? {};\n\n  const newEmit = new Proxy(originalEmit, {\n    apply(target, thisArg, args: [event: string, ...args: unknown[]]) {\n      // Only traces request events\n      if (args[0] !== 'request') {\n        return target.apply(thisArg, args);\n      }\n\n      // Make sure we do not double execute our wrapper code, for edge cases...\n      // Without this check, if we double-wrap emit, for whatever reason, you'd get two http.server spans (one the children of the other)\n      if (context.active().getValue(HTTP_SERVER_INSTRUMENTED_KEY)) {\n        return target.apply(thisArg, args);\n      }\n\n      DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Handling incoming request');\n\n      const client = getClient<NodeClient>();\n      const isolationScope = getIsolationScope().clone();\n      const request = args[1] as IncomingMessage;\n      const response = args[2] as ServerResponse & { socket: Socket };\n\n      const normalizedRequest = httpRequestToRequestData(request);\n\n      // request.ip is non-standard but some frameworks set this\n      const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;\n\n      const url = request.url || '/';\n      if (maxIncomingRequestBodySize !== 'none' && !ignoreIncomingRequestBody?.(url, request)) {\n        patchRequestToCaptureBody(request, isolationScope, maxIncomingRequestBodySize);\n      }\n\n      // Update the isolation scope, isolate this request\n      isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });\n\n      // attempt to update the scope's `transactionName` based on the request URL\n      // Ideally, framework instrumentations coming after the HttpInstrumentation\n      // update the transactionName once we get a parameterized route.\n      const httpMethod = (request.method || 'GET').toUpperCase();\n      const httpTargetWithoutQueryFragment = stripUrlQueryAndFragment(url);\n\n      const bestEffortTransactionName = `${httpMethod} ${httpTargetWithoutQueryFragment}`;\n\n      isolationScope.setTransactionName(bestEffortTransactionName);\n\n      if (trackIncomingRequestsAsSessions !== false) {\n        recordRequestSession({\n          requestIsolationScope: isolationScope,\n          response,\n          sessionFlushingDelayMS: sessionFlushingDelayMS ?? 60_000,\n        });\n      }\n\n      return withIsolationScope(isolationScope, () => {\n        // Set a new propagationSpanId for this request\n        // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope\n        // This way we can save an \"unnecessary\" `withScope()` invocation\n        getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();\n\n        const ctx = propagation\n          .extract(context.active(), normalizedRequest.headers)\n          .setValue(HTTP_SERVER_INSTRUMENTED_KEY, true);\n\n        return context.with(ctx, () => {\n          // if opting out of span creation, we can end here\n          if (\n            (typeof __SENTRY_TRACING__ !== 'undefined' && !__SENTRY_TRACING__) ||\n            !spans ||\n            !client ||\n            shouldIgnoreSpansForIncomingRequest(request, {\n              ignoreStaticAssets,\n              ignoreSpansForIncomingRequests,\n            })\n          ) {\n            DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Skipping span creation for incoming request');\n            return target.apply(thisArg, args);\n          }\n\n          const fullUrl = normalizedRequest.url || url;\n          const urlObj = parseStringToURLObject(fullUrl);\n\n          const headers = request.headers;\n          const userAgent = headers['user-agent'];\n          const ips = headers['x-forwarded-for'];\n          const httpVersion = request.httpVersion;\n          const host = headers.host;\n          const hostname = host?.replace(/^(.*)(:[0-9]{1,5})/, '$1') || 'localhost';\n\n          const tracer = client.tracer;\n          const scheme = fullUrl.startsWith('https') ? 'https' : 'http';\n\n          // We use the plain tracer.startSpan here so we can pass the span kind\n          const span = tracer.startSpan(bestEffortTransactionName, {\n            kind: SpanKind.SERVER,\n            attributes: {\n              // Sentry specific attributes\n              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.http',\n              'sentry.http.prefetch': isKnownPrefetchRequest(request) || undefined,\n              // Old Semantic Conventions attributes - added for compatibility with what `@opentelemetry/instrumentation-http` output before\n              'http.url': fullUrl,\n              'http.method': httpMethod,\n              'http.target': urlObj ? `${urlObj.pathname}${urlObj.search}` : httpTargetWithoutQueryFragment,\n              'http.host': host,\n              'net.host.name': hostname,\n              'http.client_ip': typeof ips === 'string' ? ips.split(',')[0] : undefined,\n              'http.user_agent': userAgent,\n              'http.scheme': scheme,\n              'http.flavor': httpVersion,\n              'net.transport': httpVersion?.toUpperCase() === 'QUIC' ? 'ip_udp' : 'ip_tcp',\n              ...getRequestContentLengthAttribute(request),\n            },\n          });\n\n          // TODO v11: Remove the following three hooks, only incomingRequestSpanHook should remain\n          requestHook?.(span, request);\n          responseHook?.(span, response);\n          applyCustomAttributesOnSpan?.(span, request, response);\n          incomingRequestSpanHook?.(span, request, response);\n\n          const rpcMetadata: RPCMetadata = {\n            type: RPCType.HTTP,\n            span,\n          };\n\n          context.with(setRPCMetadata(trace.setSpan(context.active(), span), rpcMetadata), () => {\n            context.bind(context.active(), request);\n            context.bind(context.active(), response);\n\n            // Ensure we only end the span once\n            // E.g. error can be emitted before close is emitted\n            let isEnded = false;\n            function endSpan(status: SpanStatus): void {\n              if (isEnded) {\n                return;\n              }\n\n              isEnded = true;\n\n              const newAttributes = getIncomingRequestAttributesOnResponse(request, response);\n              span.setAttributes(newAttributes);\n              span.setStatus(status);\n              span.end();\n\n              // Update the transaction name if the route has changed\n              const route = newAttributes['http.route'];\n              if (route) {\n                getIsolationScope().setTransactionName(`${request.method?.toUpperCase() || 'GET'} ${route}`);\n              }\n            }\n\n            response.on('close', () => {\n              endSpan(getSpanStatusFromHttpCode(response.statusCode));\n            });\n            response.on(errorMonitor, () => {\n              const httpStatus = getSpanStatusFromHttpCode(response.statusCode);\n              // Ensure we def. have an error status here\n              endSpan(httpStatus.code === SPAN_STATUS_ERROR ? httpStatus : { code: SPAN_STATUS_ERROR });\n            });\n\n            return target.apply(thisArg, args);\n          });\n        });\n      });\n    },\n  });\n\n  wrappedEmitFns.add(newEmit);\n  server.emit = newEmit;\n}\n\n/**\n * Starts a session and tracks it in the context of a given isolation scope.\n * When the passed response is finished, the session is put into a task and is\n * aggregated with other sessions that may happen in a certain time window\n * (sessionFlushingDelayMs).\n *\n * The sessions are always aggregated by the client that is on the current scope\n * at the time of ending the response (if there is one).\n */\n// Exported for unit tests\nexport function recordRequestSession({\n  requestIsolationScope,\n  response,\n  sessionFlushingDelayMS,\n}: {\n  requestIsolationScope: Scope;\n  response: EventEmitter;\n  sessionFlushingDelayMS?: number;\n}): void {\n  requestIsolationScope.setSDKProcessingMetadata({\n    requestSession: { status: 'ok' },\n  });\n  response.once('close', () => {\n    // We need to grab the client off the current scope instead of the isolation scope because the isolation scope doesn't hold any client out of the box.\n    const client = getClient();\n    const requestSession = requestIsolationScope.getScopeData().sdkProcessingMetadata.requestSession;\n\n    if (client && requestSession) {\n      DEBUG_BUILD && debug.log(`Recorded request session with status: ${requestSession.status}`);\n\n      const roundedDate = new Date();\n      roundedDate.setSeconds(0, 0);\n      const dateBucketKey = roundedDate.toISOString();\n\n      const existingClientAggregate = clientToRequestSessionAggregatesMap.get(client);\n      const bucket = existingClientAggregate?.[dateBucketKey] || { exited: 0, crashed: 0, errored: 0 };\n      bucket[({ ok: 'exited', crashed: 'crashed', errored: 'errored' } as const)[requestSession.status]]++;\n\n      if (existingClientAggregate) {\n        existingClientAggregate[dateBucketKey] = bucket;\n      } else {\n        DEBUG_BUILD && debug.log('Opened new request session aggregate.');\n        const newClientAggregate = { [dateBucketKey]: bucket };\n        clientToRequestSessionAggregatesMap.set(client, newClientAggregate);\n\n        const flushPendingClientAggregates = (): void => {\n          clearTimeout(timeout);\n          unregisterClientFlushHook();\n          clientToRequestSessionAggregatesMap.delete(client);\n\n          const aggregatePayload: AggregationCounts[] = Object.entries(newClientAggregate).map(\n            ([timestamp, value]) => ({\n              started: timestamp,\n              exited: value.exited,\n              errored: value.errored,\n              crashed: value.crashed,\n            }),\n          );\n          client.sendSession({ aggregates: aggregatePayload });\n        };\n\n        const unregisterClientFlushHook = client.on('flush', () => {\n          DEBUG_BUILD && debug.log('Sending request session aggregate due to client flush');\n          flushPendingClientAggregates();\n        });\n        const timeout = setTimeout(() => {\n          DEBUG_BUILD && debug.log('Sending request session aggregate due to flushing schedule');\n          flushPendingClientAggregates();\n        }, sessionFlushingDelayMS).unref();\n      }\n    }\n  });\n}\n\n/**\n * This method patches the request object to capture the body.\n * Instead of actually consuming the streamed body ourselves, which has potential side effects,\n * we monkey patch `req.on('data')` to intercept the body chunks.\n * This way, we only read the body if the user also consumes the body, ensuring we do not change any behavior in unexpected ways.\n */\nfunction patchRequestToCaptureBody(\n  req: IncomingMessage,\n  isolationScope: Scope,\n  maxIncomingRequestBodySize: 'small' | 'medium' | 'always',\n): void {\n  let bodyByteLength = 0;\n  const chunks: Buffer[] = [];\n\n  DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Patching request.on');\n\n  /**\n   * We need to keep track of the original callbacks, in order to be able to remove listeners again.\n   * Since `off` depends on having the exact same function reference passed in, we need to be able to map\n   * original listeners to our wrapped ones.\n   */\n  const callbackMap = new WeakMap();\n\n  const maxBodySize =\n    maxIncomingRequestBodySize === 'small'\n      ? 1_000\n      : maxIncomingRequestBodySize === 'medium'\n        ? 10_000\n        : MAX_BODY_BYTE_LENGTH;\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.on = new Proxy(req.on, {\n      apply: (target, thisArg, args: Parameters<typeof req.on>) => {\n        const [event, listener, ...restArgs] = args;\n\n        if (event === 'data') {\n          DEBUG_BUILD &&\n            debug.log(INSTRUMENTATION_NAME, `Handling request.on(\"data\") with maximum body size of ${maxBodySize}b`);\n\n          const callback = new Proxy(listener, {\n            apply: (target, thisArg, args: Parameters<typeof listener>) => {\n              try {\n                const chunk = args[0] as Buffer | string;\n                const bufferifiedChunk = Buffer.from(chunk);\n\n                if (bodyByteLength < maxBodySize) {\n                  chunks.push(bufferifiedChunk);\n                  bodyByteLength += bufferifiedChunk.byteLength;\n                } else if (DEBUG_BUILD) {\n                  debug.log(\n                    INSTRUMENTATION_NAME,\n                    `Dropping request body chunk because maximum body length of ${maxBodySize}b is exceeded.`,\n                  );\n                }\n              } catch (err) {\n                DEBUG_BUILD && debug.error(INSTRUMENTATION_NAME, 'Encountered error while storing body chunk.');\n              }\n\n              return Reflect.apply(target, thisArg, args);\n            },\n          });\n\n          callbackMap.set(listener, callback);\n\n          return Reflect.apply(target, thisArg, [event, callback, ...restArgs]);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    // Ensure we also remove callbacks correctly\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    req.off = new Proxy(req.off, {\n      apply: (target, thisArg, args: Parameters<typeof req.off>) => {\n        const [, listener] = args;\n\n        const callback = callbackMap.get(listener);\n        if (callback) {\n          callbackMap.delete(listener);\n\n          const modifiedArgs = args.slice();\n          modifiedArgs[1] = callback;\n          return Reflect.apply(target, thisArg, modifiedArgs);\n        }\n\n        return Reflect.apply(target, thisArg, args);\n      },\n    });\n\n    req.on('end', () => {\n      try {\n        const body = Buffer.concat(chunks).toString('utf-8');\n        if (body) {\n          // Using Buffer.byteLength here, because the body may contain characters that are not 1 byte long\n          const bodyByteLength = Buffer.byteLength(body, 'utf-8');\n          const truncatedBody =\n            bodyByteLength > maxBodySize\n              ? `${Buffer.from(body)\n                  .subarray(0, maxBodySize - 3)\n                  .toString('utf-8')}...`\n              : body;\n\n          isolationScope.setSDKProcessingMetadata({ normalizedRequest: { data: truncatedBody } });\n        }\n      } catch (error) {\n        if (DEBUG_BUILD) {\n          debug.error(INSTRUMENTATION_NAME, 'Error building captured request body', error);\n        }\n      }\n    });\n  } catch (error) {\n    if (DEBUG_BUILD) {\n      debug.error(INSTRUMENTATION_NAME, 'Error patching request to capture body', error);\n    }\n  }\n}\n\nfunction getRequestContentLengthAttribute(request: IncomingMessage): SpanAttributes {\n  const length = getContentLength(request.headers);\n  if (length == null) {\n    return {};\n  }\n\n  if (isCompressed(request.headers)) {\n    return {\n      ['http.request_content_length']: length,\n    };\n  } else {\n    return {\n      ['http.request_content_length_uncompressed']: length,\n    };\n  }\n}\n\nfunction getContentLength(headers: IncomingHttpHeaders): number | null {\n  const contentLengthHeader = headers['content-length'];\n  if (contentLengthHeader === undefined) return null;\n\n  const contentLength = parseInt(contentLengthHeader as string, 10);\n  if (isNaN(contentLength)) return null;\n\n  return contentLength;\n}\n\nfunction isCompressed(headers: IncomingHttpHeaders): boolean {\n  const encoding = headers['content-encoding'];\n\n  return !!encoding && encoding !== 'identity';\n}\n\nfunction getIncomingRequestAttributesOnResponse(request: IncomingMessage, response: ServerResponse): SpanAttributes {\n  // take socket from the request,\n  // since it may be detached from the response object in keep-alive mode\n  const { socket } = request;\n  const { statusCode, statusMessage } = response;\n\n  const newAttributes: SpanAttributes = {\n    [ATTR_HTTP_RESPONSE_STATUS_CODE]: statusCode,\n    // eslint-disable-next-line deprecation/deprecation\n    [SEMATTRS_HTTP_STATUS_CODE]: statusCode,\n    'http.status_text': statusMessage?.toUpperCase(),\n  };\n\n  const rpcMetadata = getRPCMetadata(context.active());\n  if (socket) {\n    const { localAddress, localPort, remoteAddress, remotePort } = socket;\n    // eslint-disable-next-line deprecation/deprecation\n    newAttributes[SEMATTRS_NET_HOST_IP] = localAddress;\n    // eslint-disable-next-line deprecation/deprecation\n    newAttributes[SEMATTRS_NET_HOST_PORT] = localPort;\n    // eslint-disable-next-line deprecation/deprecation\n    newAttributes[SEMATTRS_NET_PEER_IP] = remoteAddress;\n    newAttributes['net.peer.port'] = remotePort;\n  }\n  // eslint-disable-next-line deprecation/deprecation\n  newAttributes[SEMATTRS_HTTP_STATUS_CODE] = statusCode;\n  newAttributes['http.status_text'] = (statusMessage || '').toUpperCase();\n\n  if (rpcMetadata?.type === RPCType.HTTP && rpcMetadata.route !== undefined) {\n    const routeName = rpcMetadata.route;\n    newAttributes[ATTR_HTTP_ROUTE] = routeName;\n  }\n\n  return newAttributes;\n}\n\nfunction isKnownPrefetchRequest(req: IncomingMessage): boolean {\n  // Currently only handles Next.js prefetch requests but may check other frameworks in the future.\n  return req.headers['next-router-prefetch'] === '1';\n}\n\n/**\n * Check if a request is for a common static asset that should be ignored by default.\n *\n * Only exported for tests.\n */\nexport function isStaticAssetRequest(urlPath: string): boolean {\n  const path = stripUrlQueryAndFragment(urlPath);\n  // Common static file extensions\n  if (path.match(/\\.(ico|png|jpg|jpeg|gif|svg|css|js|woff|woff2|ttf|eot|webp|avif)$/)) {\n    return true;\n  }\n\n  // Common metadata files\n  if (path.match(/^\\/(robots\\.txt|sitemap\\.xml|manifest\\.json|browserconfig\\.xml)$/)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction shouldIgnoreSpansForIncomingRequest(\n  request: IncomingMessage,\n  {\n    ignoreStaticAssets,\n    ignoreSpansForIncomingRequests,\n  }: {\n    ignoreStaticAssets?: boolean;\n    ignoreSpansForIncomingRequests?: (urlPath: string, request: IncomingMessage) => boolean;\n  },\n): boolean {\n  if (isTracingSuppressed(context.active())) {\n    return true;\n  }\n\n  // request.url is the only property that holds any information about the url\n  // it only consists of the URL path and query string (if any)\n  const urlPath = request.url;\n\n  const method = request.method?.toUpperCase();\n  // We do not capture OPTIONS/HEAD requests as spans\n  if (method === 'OPTIONS' || method === 'HEAD' || !urlPath) {\n    return true;\n  }\n\n  // Default static asset filtering\n  if (ignoreStaticAssets && method === 'GET' && isStaticAssetRequest(urlPath)) {\n    return true;\n  }\n\n  if (ignoreSpansForIncomingRequests?.(urlPath, request)) {\n    return true;\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"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"}